name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  AWS_REGION: eu-central-1
  ECR_REPOSITORY: number-acidizer-backend
  NODE_VERSION: '18'

jobs:
  test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm run install:all

      - name: Lint backend
        run: npm run lint:backend

      - name: Lint frontend
        run: npm run lint:frontend

      - name: Test backend e2e
        run: npm run test:backend:e2e

      - name: Test backend unit
        run: npm run test:backend:unit

      # - name: Test frontend
      #   run: npm run test:frontend

      - name: Build backend
        run: npm run build:backend

      - name: Build frontend
        run: npm run build:frontend

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Install dependencies
        run: npm run install:all

      - name: Build application
        run: npm run build

      - name: Setup Terraform Backend
        id: setup-backend
        run: |
          cd infrastructure

          # Generate unique bucket name
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="number-acidizer-terraform-state-${ACCOUNT_ID}"
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

          # Check if bucket exists, create if not
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating Terraform state bucket: $BUCKET_NAME"
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region ${{ env.AWS_REGION }}
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{
              "Rules": [{
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }]
            }'
            aws s3api put-public-access-block --bucket "$BUCKET_NAME" --public-access-block-configuration '{
              "BlockPublicAcls": true,
              "IgnorePublicAcls": true,
              "BlockPublicPolicy": true,
              "RestrictPublicBuckets": true
            }'
          fi

          # Check if DynamoDB lock table exists, create if not
          LOCK_TABLE="number-acidizer-terraform-locks"
          if ! aws dynamodb describe-table --table-name "$LOCK_TABLE" 2>/dev/null; then
            echo "Creating Terraform lock table: $LOCK_TABLE"
            aws dynamodb create-table \
              --table-name "$LOCK_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}
            
            # Wait for table to be active
            aws dynamodb wait table-exists --table-name "$LOCK_TABLE"
          fi

      - name: Initialize Terraform
        run: |
          cd infrastructure
          terraform init \
            -backend-config="bucket=${{ steps.setup-backend.outputs.bucket_name }}" \
            -backend-config="key=number-acidizer/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=number-acidizer-terraform-locks"

      - name: Get ECR repository URI
        id: ecr-repo
        run: |
          cd infrastructure
          ECR_URI=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
          if [ -z "$ECR_URI" ]; then
            # First deployment - create ECR repository
            terraform apply -auto-approve -target=aws_ecr_repository.backend
            ECR_URI=$(terraform output -raw ecr_repository_url)
          fi
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REPOSITORY: ${{ steps.ecr-repo.outputs.ecr_uri }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd backend
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REPOSITORY:latest .
          docker push $ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REPOSITORY:latest

      - name: Deploy infrastructure
        env:
          TF_VAR_environment: prod
        run: |
          cd infrastructure
          terraform plan -out=tfplan
          terraform apply tfplan

      - name: Update Lambda function
        run: |
          cd infrastructure
          aws lambda update-function-code \
            --function-name $(terraform output -raw lambda_functions | jq -r '.api') \
            --image-uri ${{ steps.ecr-repo.outputs.ecr_uri }}:${{ github.sha }}
          aws lambda update-function-code \
            --function-name $(terraform output -raw lambda_functions | jq -r '.stream_handler') \
            --image-uri ${{ steps.ecr-repo.outputs.ecr_uri }}:${{ github.sha }}

      - name: Deploy frontend to S3
        run: |
          cd infrastructure
          S3_BUCKET=$(terraform output -raw s3_bucket)
          aws s3 sync ../frontend/dist/ s3://$S3_BUCKET --delete

      - name: Invalidate CloudFront
        run: |
          cd infrastructure
          DISTRIBUTION_ID=$(terraform output -raw cloudfront_distribution_id)
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"

      - name: Run post-deployment tests
        run: |
          cd infrastructure
          API_URL=$(terraform output -raw api_url)
          cd ../tests
          API_URL=$API_URL npm test

  cleanup:
    name: Cleanup old ECR images
    runs-on: ubuntu-latest
    needs: deploy
    if: always() && github.ref == 'refs/heads/main'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Cleanup old ECR images
        run: |
          aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} --filter tagStatus=UNTAGGED --query 'imageIds[?imageDigest!=null]' --output json | jq '.[] | select(.imagePushedAt < (now - 604800))' | while read image; do
            aws ecr batch-delete-image --repository-name ${{ env.ECR_REPOSITORY }} --image-ids "$image"
          done
